## Classes confuse both people and machines

- Ã‰ necessÃ¡rio entender como o `this` funciona no Javascript
- Lembrar de fazer o `bind` de todos os `event handlers` (atualmente a aplicaÃ§Ã£o faz um mix e cria funÃ§Ãµes a cada render do componente)

```jsx
// Sem bind, a funÃ§Ã£o Ã© criada novamente em todos os renders
class Input extends React.Component {
  state = "";

  handleChange(text) {
    this.setState(text);
  }

  render() {
    return (
      //                             ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡
      <input value={state} onChange={ev => handleChange(ev.target.value)} />
    );
  }
}
```

```jsx
class Input extends React.Component {
  constructor() {
    this.state = "";
    // o bind aqui Ã³ ğŸ‘‡
    this.handleChange = this.handleChange.bind(this);
  }

  handleChange(ev) {
    this.setState(ev.target.value);
  }

  render() {
    return <input value={state} onChange={handleChange} />;
  }
}
```

> [..] Recently, weâ€™ve been experimenting with component folding using Prepack, and weâ€™ve seen promising early results. However, we found that class components can encourage unintentional patterns that make these optimizations fall back to a slower path.

> Classes present issues for todayâ€™s tools, too. For example, classes donâ€™t minify very well, and they make hot reloading flaky and unreliable.
